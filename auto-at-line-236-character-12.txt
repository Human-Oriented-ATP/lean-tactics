main_jumps : JumpSet
main_mines : MineField
J : Jump
jumps : JumpSet
mines0 : MineField
mines1 : MineField
mines00 : MineField
mines01 : MineField
mines10 : MineField
mines11 : MineField
jumpso : Jumps
jumps0 : Jumps
J2 : Jump
jumps1 : Jumps

---
Multiset.Nodup(main_jumps)
EQUALS(JumpSet.sum(main_jumps), HAdd.hAdd(↑(MineField.length(main_mines)), 1))
LT(MineField.countMines(main_mines), ↑(Multiset.sizeOf(main_jumps)))
NOT(EQUALS(MineField.countMines(main_mines), 0))
EQUALS(main_jumps, Multiset.cons(J, jumps))
x : Jump :: IMPLIES(Membership.mem(x, main_jumps), LE(Jump.length(x), Jump.length(J)))
EQUALS(main_mines, HAppend.hAppend(mines0, mines1))
EQUALS(↑(MineField.length(mines0)), Jump.length(J))
EQUALS(mines0, HAppend.hAppend(mines00, mines01))
EQUALS(↑(MineField.length(mines00)), HSub.hSub(Jump.length(J), 1))
NOT(EQUALS(List.getIndexD(mines01, 0), true))
EQUALS(mines1, HAppend.hAppend(HAppend.hAppend(mines10, singleton(true)), mines11))
EQUALS(MineField.countMines(mines10), 0)
EQUALS(jumps, Jumps.s(jumpso))
x : ℤ :: OR(NOT(EQUALS(List.getIndexD(Jumps.landings(jumpso), x), true)), NOT(EQUALS(List.getIndexD(HAppend.hAppend(HAppend.hAppend(mines10, singleton(false)), mines11), x), true)))
EQUALS(jumpso, HAppend.hAppend(HAppend.hAppend(jumps0, singleton(J2)), jumps1))
AND(LE(Jumps.sum(jumps0), HAdd.hAdd(↑(MineField.length(mines10)), 1)), LT(HAdd.hAdd(↑(MineField.length(mines10)), 1), HAdd.hAdd(Jumps.sum(jumps0), Jump.length(J2))))
NOT(EQUALS(main_jumps, Jumps.s(HAppend.hAppend(HAppend.hAppend(HAppend.hAppend(jumps0, singleton(J2)), singleton(J)), jumps1))))
EQUALS(MineField.countMines(mines0), 0)
EQUALS(List.getIndexD(Jumps.landings(jumpso), ↑(MineField.length(mines10))), true)
