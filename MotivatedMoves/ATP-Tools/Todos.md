# ATP Tools

## General 

- A function that returns the array of constants appearing in a problem state.  

- A discrimination tree for all subexpressions

- A function that returns all valid `SubExpr.Pos` in a given expression

- - A function that accepts a pattern and returns the list of `GoalsLocations` where it occurs

- A function that returns all valid `GoalsLocation` in a given target 

## For generating subtasks

- A function that given a problem state returns the constants that appear in the target but not in the hypotheses.

- A function that given a problem state returns minmimal subterms that appear in the target but not in the hypotheses.

- Alike but including the number of occurences.

- A data structure that keeps track of which hypotheses have been used already. It should be a graph that is initialized to `(V = [hypotheses, targets], E = {})` and such that: 
    - New vertices can be added (e.g. one applies a lemma and adds it to the hypotheses)
    - New edges can be added (a hypothesis is used to change the target)
    - One can query for any two vertices if they are conneteced

## For evaluating available options 

- Given a lemma, return if it can be used to modify a given problem state (i.e. rewritten/applied)

- Given a constant `c`, return all lemmas that can be *applied* to directly destroy this constant (i.e. it features in the target but not in the hypotheses).

- Given a constant `c`, return all lemmas that can be *rewritten* to directly destroy this constant (i.e. it appears on one side of the equality but not on the other).

- Given a type `α`, return all lemmas that can be applied/used for rewriting to destroy a term of type α. 

- Alike but for arbitrary subterms.

- Given two lemmas l1 and l2, return how they interact in the following sense 
    - If one can use l1 (on a given problem state) then one can use l2
    - After using l1, one can always use l2
    - If one can use l1 and l2 (on a given problem state) then one can still use l2 after using l1
  Here *use* is to be understood as applied or rewritten, depending on the target type of l1, l2. 

## Experts and theories

- Given a list of constants `cs`, return all theorems whose set of constant is a subset of `cs`. It should be possible to configure if logical connectives, ∃ and equality should be counted as constants. 

- Given a list of constants `cs`, project a problem state into the language generated by `cs`. That is, if `cs = [0, =]` then `a + 0 = 1 + b` is projected to `P 0 = Q` where `P, Q` are new free variables. 

## Technical 

- Utility functions that preprocess Lean expressions to hide information. This could e.g. include let-reduction, removing `Expr.mdata` or `Expr.proj` etc. 

- Filtering on the environment declarations that excludes certain technical definitions/theorems. This should e.g. include filtering out anything in the `Lean` namespace and might be inspired by the discrimination tree blacklist.  
